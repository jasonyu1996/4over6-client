##IPV4 over IPV6隧道协议实验 实验报告

#### 组员：

##### 于志竟成 2015011xxx（待填写）

##### 何欣蔚 2015011253



### 一、实验目的和实验要求

#### 实验目的

IPV4 over IPV6，简称“4over6”是IPV4向IPV6发展进程中，向纯IPV6主干网过渡提出的一种新技术，可以最大程度地继承基于IPV4网络和应用，实现IPV4向IPV6平滑的过渡。

该实验通过实现IPV4 over IPV6隧道最小原型验证系统，让同学们对4over6隧道的实现原理有更加深刻的认识。

#### 实验要求

在安卓设备上实现一个4over6隧道系统的客户端程序，内容如下：

- 实现安卓界面程序，显示隧道报文收发状态(java语言)；
- 启用安卓VPN服务(java语言)；
- 实现底层通信程序，对4over6隧道系统控制消息和数据消息的处理(C语言)。



### 二、前台

前台主要实现安卓界面程序，显示隧道报文收发状态，主要用java语言实现。其功能大致能概述如下：

- 进行网络检测并获取上联物理接口IPV6地址；
- 启动后台线程；
- 开启定时器刷新界面；
- 界面显示网络状态；
- 开启安卓VPN服务。

主要的模块分为主模块（界面显示、定时器逻辑），VPN服务模块和界面文件 `activity_ivi.xml` .

#### 主模块（IVI）

前台的主体逻辑主要在 `IVI.java` 中实现，这也是整个Android app的主界面 `AppCompatActivity` .

前台主模块（IVI）中，获取IPV6地址的功能由函数 `getLocalHostIp()` 完成，activity中还定义了名为 `mTimer` 的 `Timer` 定时器，定时器的循环判断和数据读取功能由 `timerTask()` 函数完成，定时器线程和主线程的沟通以及对于网络信息数据的处理显示主要在名为 `mHandler` 的 `Handler` 中完成，开启安卓VPN服务的功能则主要通过唤起后台服务 `mVPNService` 来实现，这一点会在后面的部分详细提及。

下面对主模块中最重要的 `mTimer` ，`timerTask()` 和 `mHandler` 做较为细致的介绍。

##### mTimer 和 timerTask()

`mTimer` 是一个 `Timer` 定时器，通过语句 `mTimer = new Timer()` 来声明和构造，它的详细定义和功能则在函数 `timerTask()` 中得到定义。

`timerTask()` 中，通过调用 `mTimer.schedule(new TimerTask() {...}, 1000, 1000)` 来为定时器 `mTimer` 的功能逻辑做详细定义。其中主要重载了函数 `run()` ，在其中实现了循环逻辑判断和计时的功能。

主模块IVI activity中的变量 `int flag` 是函数逻辑判断的依据。当定时器刚刚运行时，`flag` 置0，表示尚未从后台读取到IP地址信息，这种情况下，定时器线程每循环一次，都试图从前后台通信的管道中读取20字节长的ip地址信息，并向主线程中的 `mHandler` 发送一个 `what` 为“2”的空白信息，提示主线程需要试图解析数据中的ip地址信息。若ip地址信息成功得到解析且非全0，则主线程将 `flag` 置1，主线程依据获得的ip地址信息开启后台VPN服务，此时定时器线程每循环一次都试图从前后台通信的管道中读取32字节长的流量信息，并向主线程中的 `mHandler` 发送一个 `what` 为“3”的空白信息，提示主线程需要试图解析数据中的流量信息。除此之外，无论 `flag` 是0还是1，定时器线程每循环一次都会向主线程发送一个 `what` 为“1”的空白信息，提示主线程刷新前台显示数据，保证前台能够及时更新相应数据信息的显示。

##### mHandler

`mHandler` 是在IVI activity中声明和构造的一个 `Handler` ，主要用于处理定时器线程发给主线程的 `Message` 信息。对 `Message` 中信息的具体判断和操作如下表所示。

| `Message.what`的值 |       意义和需求       |                `mHandler` 处理逻辑                 |
| :----------------: | :--------------------: | :------------------------------------------------: |
|         1          |  需要刷新前台显示界面  |        对前台显示xml文件中的元素做数据更新         |
|         2          | 需要试图解析ip地址信息 | 从20字节长数据中解析20个8bit整数，整合成ip地址信息 |
|         3          |  需要试图解析流量信息  |  从32字节长数据中解析4个64bit整数，整合成流量信息  |

读取管道、解析ip地址和流量信息数据时还涉及到IVI activity中的一些其他函数，但功能较为简单明了，实现也较为简易直观，主要起一些解析作用，设计一些字符串和byte数组的操作，在此就不单独介绍了。

#### VPN服务模块（mVPNService）

VPN服务在 `mVPNServce.java` 中实现，是一个 `VpnService` .

当前台主模块IVI activity成功从前后台通讯管道中获取到ip地址信息（20个8bit整数四个四个为一组，共五组，分别表示ipv4addr、route、DNS1、DNS2、DNS3）时，便会依据ip地址信息开启VPN服务。

在开启VPN服务之前，app需要进行一些准备工作，在主模块IVI activity中，会通过弹窗请求用户为其开启VPN提供许可，若用户允许开放VPN权限，则app能够顺利唤起mVPNService . 在开启的过程中，前台主模块IVI activity会通过intent向mVPNService传输上述得到的ip地址信息以及通过唤起后台服务而获得的 `socketFd` ，这也是mVPNService中需要进行保护的端口描述符。

在mVPNService中，开启VPN服务的实现也较为简单。首先通过 `Builder` 来配置开启VPN服务所需的相应信息，再通过 `ParcelFileDescriptor mInterface = builder.establish();` 来开启VPN服务。此后，通过前后台通信管道将 `mInterface` 的文件描述符（通过 `int interfaceFd = mInterface.getFd();` 获取）传到后台。接下来调用 `protect(protectFd)` 来对端口本身进行保护，防止数据包在隧道中循环传输。（这里的 `protectFD` 就是前台主模块IVI activity在开启mVpnService时通过Intent传输过来的 `socketFd` . ）

#### 界面文件

Android界面文件 `activity_ivi.xml` 确定了app的界面主体显示框架。其中简单实现了三个数据显示卡片cardview，通过内嵌的textview分别实现了路由信息、流量信息和运行时长的显示。除此之外在界面右下角有一个浮动按钮，通过它能够实现服务的开启和关闭，并针对具体的开/关状态切换给出相应的底部snackbar提示。

在前台主模块IVI activity需要刷新页面数据显示时，对界面文件中相应textview进行内容上的修改即可。

![androidxml](androidxml.jpg)



### 三、后台

（待填写）



### 四、前后台通信

app的前后台通信主要通过读写具名管道来实现。具体的读写实现（无论是在java语言还是在c语言中）较为基础，读写时机在之前的部分也已有相应的提及。此部分对前后台通信的时机做一个整体的梳理，便于了解前后台通信的宏观逻辑。

|        通信时机         | 读/写管道 |           通信内容           | 数据大小 |     解析     |
| :---------------------: | :-------: | :--------------------------: | :------: | :----------: |
|       （待填写）        |  写管道   |   后台向前台发送ip地址信息   |  20Byte  | 20个8bit整数 |
| `flag`为0，定时器循环时 |  读管道   |   前台从后台读取ip地址信息   |  20Byte  | 20个8bit整数 |
|    VpnService开启时     |  写管道   | 前台向后台发送端口文件描述符 |  4Byte   | 1个32bit整数 |
|       （待填写）        |  读管道   | 后台从前台读取端口文件描述符 |  4Byte   | 1个32bit整数 |
|       （待填写）        |  写管道   |    后台向前台发送流量信息    |  32Byte  | 4个64bit整数 |
| `flag`为1，定时器循环时 |  读管道   |    前台从后台读取流量信息    |  32Byte  | 4个64bit整数 |



### 五、遇到的问题

#### app后台保活问题

##### 问题

由于Android app的后台pause/stop机制，当app被切到后台时，其VPN服务仍然能够正常运行，但主界面activity会停止更新，当app返回前台时，界面会出现停滞。

##### 解决方案

可以通过一个新的service来实现前台显示数据的实时获取，实现前后端通信和数据更新的“保活”；也可以通过在主activity中重写函数 `onSaveInstanceState()`，实现现场的保存和恢复工作并重启前台定时器来实现页面的恢复。后者比前者的开销更小，是更优的解决策略。

#### 公寓楼区和东主楼网络环境差异问题

#####问题

app在紫荆公寓楼区通过连接Tsinghua/Tsinghua-5G即可实现IPV6无线上网，也可以使隧道正常工作；而东主楼的Tsinghua/Tsinghua-5G/DIVI2为IPV4，并未提供IPV6支持，DIVI无线网的网络质量又很不好（ping服务器的延迟甚至超过400ms，在不开启隧道的情况下也无法很好地浏览网页等），均不能提供较好的IPV6网络环境。在切换到无线网TPLINK-NETLAB之后，虽然有较好的IPV6网络环境，却仍然不能成功运行app .

##### 解决方案

尝试用Wireshark抓包和分析，发现能够正常对服务器发送相应请求，却接收不到服务器的正常响应（但是能够接收到心跳包），问题的根源尚未找到，解决方案不详。应助教要求，将在公寓楼区顺利运行app的截图附在实验报告中如下。（待填写）

（待填写）

